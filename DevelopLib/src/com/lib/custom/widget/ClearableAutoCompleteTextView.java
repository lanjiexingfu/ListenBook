package com.lib.custom.widget;import android.content.Context;import android.database.DataSetObserver;import android.graphics.Rect;import android.graphics.drawable.Drawable;import android.text.Editable;import android.text.TextWatcher;import android.util.AttributeSet;import android.view.KeyEvent;import android.view.MotionEvent;import android.view.View;import android.widget.EditText;import android.widget.Filter;import android.widget.Filterable;import android.widget.ListAdapter;import android.widget.ListView;/** * 自动根据输入字符串更新listview，支持清空按钮 */public class ClearableAutoCompleteTextView extends EditText implements        Filter.FilterListener {    private ListView mListView;    private ListAdapter mAdapter;    private Filter mFilter;    private int mThreshold = 1;    private MyDataSetObserver mObserver;    private boolean mBlockCompletion;    private int mLastKeyCode = KeyEvent.KEYCODE_UNKNOWN;    private boolean mListViewCanBeUpdated;    private Drawable rightRemoveDrawable;    private boolean tappedX = false;    private OnFocusChangeListener f;    private TextChangeListener mTextChangeListener;    private OnClickListener mDeleteClickListener;    public ClearableAutoCompleteTextView(Context context) {        this(context, null);    }    public ClearableAutoCompleteTextView(Context context, AttributeSet attrs) {        super(context, attrs);        init();    }    public ClearableAutoCompleteTextView(Context context, AttributeSet attrs, int defStyle) {        super(context, attrs, defStyle);        init();    }    private void init() {        rightRemoveDrawable = getCompoundDrawables()[2];        addTextChangedListener(new MyWatcher());        setClearIconVisible(false);    }    @Override    public void setOnFocusChangeListener(OnFocusChangeListener f) {        this.f = f;    }    public void setOnTextChangeClickListener(TextChangeListener d) {        this.mTextChangeListener = d;    }    public void setOnDeleteClickListener(OnClickListener d) {        this.mDeleteClickListener = d;    }    @Override    public boolean onTouchEvent(MotionEvent event) {        if (rightRemoveDrawable != null) {            // 截取点击            if (event.getAction() == MotionEvent.ACTION_DOWN) {                tappedX = event.getX() > (getWidth()                        - getPaddingRight()                        - rightRemoveDrawable.getIntrinsicWidth());                if (tappedX) {                    return true;                }            }            // 触发自定义点击事件            if (event.getAction() == MotionEvent.ACTION_UP && tappedX) {                if (mDeleteClickListener != null) {                    mDeleteClickListener.onClick(this);                } else setText("");                clearFocus();            }        }        return super.onTouchEvent(event);    }    @Override    public void clearFocus() {        super.clearFocus();        setClearIconVisible(false);    }    protected void setClearIconVisible(boolean visible) {        if (rightRemoveDrawable != null) {            Drawable x = visible ? rightRemoveDrawable : null;            setCompoundDrawables(getCompoundDrawables()[0],                    getCompoundDrawables()[1], x, getCompoundDrawables()[3]);        }    }    /**     * 获取焦点时过滤     */    @Override    protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) {        super.onFocusChanged(focused, direction, previouslyFocusedRect);        if (focused) {            setClearIconVisible(getText().length() > 0);        } else {            setClearIconVisible(false);        }        if (f != null) {            f.onFocusChange(this, focused);        }        performFiltering(null == getText() ? "" : getText(), mLastKeyCode);    }    protected void performFiltering(CharSequence text, int keyCode) {        if (mFilter != null) {            mFilter.filter(text, this);        }    }    public void setListView(ListView listView) {        this.mListView = listView;    }    public <T extends ListAdapter & Filterable> void setAdapter(T adapter) {        if (mObserver == null) {            mObserver = new MyDataSetObserver();        } else if (mAdapter != null) {            mAdapter.unregisterDataSetObserver(mObserver);        }        mAdapter = adapter;        if (mAdapter != null) {            //noinspection unchecked            mFilter = ((Filterable) mAdapter).getFilter();            adapter.registerDataSetObserver(mObserver);        } else {            mFilter = null;        }        mListView.setAdapter(mAdapter);    }    /**     * This is used to watch for edits to the text view.  Note that we call     * to methods on the auto complete text view class so that we can access     * private vars without going through thunks.     */    private class MyWatcher implements TextWatcher {        public void afterTextChanged(Editable s) {            doAfterTextChanged();        }        public void beforeTextChanged(CharSequence s, int start, int count, int after) {            doBeforeTextChanged();        }        public void onTextChanged(CharSequence s, int start, int before, int count) {            setClearIconVisible(s.length() > 0);            if (mTextChangeListener != null) mTextChangeListener.onTextChanged(s);        }    }    void doBeforeTextChanged() {        if (mBlockCompletion) return;    }    void doAfterTextChanged() {        if (mBlockCompletion) return;        // the drop down is shown only when a minimum number of characters        // was typed in the text view        if (enoughToFilter()) {            if (mFilter != null) {                mListViewCanBeUpdated = true;                performFiltering(getText(), mLastKeyCode);            }        } else {            if (mFilter != null) {                mFilter.filter(null);            }        }    }    /**     * Identifies whether the view is currently performing a text completion, so subclasses     * can decide whether to respond to text changed events.     */    public boolean isPerformingCompletion() {        return mBlockCompletion;    }    /**     * Like {@link #setText(CharSequence)}, except that it can disable filtering.     *     * @param filter If <code>false</code>, no filtering will be performed     *               as a result of this call.     */    public void setText(CharSequence text, boolean filter) {        if (filter) {            setText(text);        } else {            mBlockCompletion = true;            setText(text);            mBlockCompletion = false;        }    }    @Override    public void onFilterComplete(int count) {        updateListViewForFilter(count);    }    private boolean enoughToFilter() {        return getText().length() >= mThreshold;    }    private void updateListViewForFilter(int count) {        // Not attached to window, don't update drop-down        if (getWindowVisibility() == View.GONE) return;        final boolean enoughToFilter = enoughToFilter();        if (count > 0 && enoughToFilter && hasFocus() && hasWindowFocus()) {            if (hasFocus() && hasWindowFocus() && mListViewCanBeUpdated) {            }        }    }    private class MyDataSetObserver extends DataSetObserver {        @Override        public void onChanged() {            if (mAdapter != null) {                // If the popup is not showing already, showing it will cause                // the list of data set observers attached to the adapter to                // change. We can't do it from here, because we are in the middle                // of iterating through the list of observers.                post(new Runnable() {                    public void run() {                        final ListAdapter adapter = mAdapter;                        if (adapter != null) {                            // This will re-layout, thus resetting mDataChanged, so that the                            // listView click listener stays responsive                            updateListViewForFilter(adapter.getCount());                        }                    }                });            }        }    }    public interface TextChangeListener {        public void onTextChanged(CharSequence newText);    }}